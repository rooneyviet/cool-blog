# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

directive @upper on FIELD_DEFINITION

"""recipe """
type Recipe {
  id: ID!
  description: String
  creationDate: DateTime!
  ingredients: [String!]!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserCountAggregate {
  id: Int!
  createdAt: Int!
  updatedAt: Int!
  email: Int!
  username: Int!
  userStatus: Int!
  role: Int!
  _all: Int!
}

type UserMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String
  username: String
  userStatus: String
  role: Role
}

enum Role {
  ADMIN
  USER
}

type UserMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String
  username: String
  userStatus: String
  role: Role
}

type AggregateUser {
  _count: UserCountAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

type UserCount {
  posts: Int!
  likes: Int!
  comments: Int!
}

type UserGroupBy {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  username: String!
  userStatus: String!
  role: Role!
  _count: UserCountAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

type CategoryCount {
  posts: Int!
}

type Category {
  id: ID!
  name: String!
  description: String
  posts: [CategoriesOnPosts!]
  _count: CategoryCount!
}

type CategoriesOnPosts {
  postId: String!
  categoryId: String!
  assignedAt: DateTime!
  assignedBy: String!
  post: Post!
  category: Category!
}

type Like {
  id: ID!
  userId: String!
  postId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  post: Post!
}

type Comment {
  id: ID!
  text: String!
  postId: String!
  userId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  post: Post!
  user: User!
}

type PostCount {
  categories: Int!
  likes: Int!
  comments: Int!
}

type Post {
  id: ID!
  url: String
  createdAt: DateTime!
  views: Int!
  updatedAt: DateTime!
  published: Boolean!
  title: String!
  content: String!
  authorId: String
  author: User
  categories: [CategoriesOnPosts!]
  likes: [Like!]
  comments: [Comment!]
  _count: PostCount!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  """@Validator.@IsEmail()"""
  email: String!
  username: String!
  userStatus: String!
  role: Role!
  posts: [Post!]
  likes: [Like!]
  comments: [Comment!]
  _count: UserCount!
}

type LoginDataResponse {
  access_token: String
  status: Boolean!
  error: String
}

type AffectedRows {
  count: Int!
}

type PostCountAggregate {
  id: Int!
  url: Int!
  createdAt: Int!
  views: Int!
  updatedAt: Int!
  published: Int!
  title: Int!
  content: Int!
  authorId: Int!
  _all: Int!
}

type PostAvgAggregate {
  views: Float
}

type PostSumAggregate {
  views: Int
}

type PostMinAggregate {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean
  title: String
  content: String
  authorId: String
}

type PostMaxAggregate {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean
  title: String
  content: String
  authorId: String
}

type AggregatePost {
  _count: PostCountAggregate
  _avg: PostAvgAggregate
  _sum: PostSumAggregate
  _min: PostMinAggregate
  _max: PostMaxAggregate
}

type PostGroupBy {
  id: String!
  url: String
  createdAt: DateTime!
  views: Int!
  updatedAt: DateTime!
  published: Boolean!
  title: String!
  content: String!
  authorId: String
  _count: PostCountAggregate
  _avg: PostAvgAggregate
  _sum: PostSumAggregate
  _min: PostMinAggregate
  _max: PostMaxAggregate
}

type Query {
  recipe(id: String!): Recipe!
  recipes(skip: Int! = 0, take: Int! = 25): [Recipe!]!
  findFirstUser(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!], relationLoadStrategy: RelationLoadStrategy): User!
  findUniqueUser(where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User!
  listUsers(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!], relationLoadStrategy: RelationLoadStrategy): [User!]!
  groupByUser(where: UserWhereInput, orderBy: [UserOrderByWithAggregationInput!], by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, take: Int, skip: Int, _count: UserCountAggregateInput, _min: UserMinAggregateInput, _max: UserMaxAggregateInput): [UserGroupBy!]!
  aggregateUser(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, _count: UserCountAggregateInput, _min: UserMinAggregateInput, _max: UserMaxAggregateInput): AggregateUser!
  login(email: String!, password: String!): LoginDataResponse!
  findFirstPost(where: PostWhereInput, orderBy: [PostOrderByWithRelationInput!], cursor: PostWhereUniqueInput, take: Int, skip: Int, distinct: [PostScalarFieldEnum!], relationLoadStrategy: RelationLoadStrategy): Post!
  findUniquePost(where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post!
  listPosts(postWhereInputArgs: PostWhereInput!): [Post!]!
  groupByPost(where: PostWhereInput, orderBy: [PostOrderByWithAggregationInput!], by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, take: Int, skip: Int, _count: PostCountAggregateInput, _avg: PostAvgAggregateInput, _sum: PostSumAggregateInput, _min: PostMinAggregateInput, _max: PostMaxAggregateInput): [PostGroupBy!]!
  aggregatePost(where: PostWhereInput, orderBy: [PostOrderByWithRelationInput!], cursor: PostWhereUniqueInput, take: Int, skip: Int, _count: PostCountAggregateInput, _avg: PostAvgAggregateInput, _sum: PostSumAggregateInput, _min: PostMinAggregateInput, _max: PostMaxAggregateInput): AggregatePost!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  email: StringFilter
  username: StringFilter
  userStatus: StringFilter
  password: StringFilter
  role: EnumRoleFilter
  posts: PostListRelationFilter
  likes: LikeListRelationFilter
  comments: CommentListRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input PostListRelationFilter {
  every: PostWhereInput
  some: PostWhereInput
  none: PostWhereInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
  id: StringFilter
  url: StringNullableFilter
  createdAt: DateTimeFilter
  views: IntFilter
  updatedAt: DateTimeFilter
  published: BoolFilter
  title: StringFilter
  content: StringFilter
  authorId: StringNullableFilter
  author: UserNullableRelationFilter
  categories: CategoriesOnPostsListRelationFilter
  likes: LikeListRelationFilter
  comments: CommentListRelationFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input CategoriesOnPostsListRelationFilter {
  every: CategoriesOnPostsWhereInput
  some: CategoriesOnPostsWhereInput
  none: CategoriesOnPostsWhereInput
}

input CategoriesOnPostsWhereInput {
  AND: [CategoriesOnPostsWhereInput!]
  OR: [CategoriesOnPostsWhereInput!]
  NOT: [CategoriesOnPostsWhereInput!]
  postId: StringFilter
  categoryId: StringFilter
  assignedAt: DateTimeFilter
  assignedBy: StringFilter
  post: PostRelationFilter
  category: CategoryRelationFilter
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  id: StringFilter
  name: StringFilter
  description: StringNullableFilter
  posts: CategoriesOnPostsListRelationFilter
}

input LikeListRelationFilter {
  every: LikeWhereInput
  some: LikeWhereInput
  none: LikeWhereInput
}

input LikeWhereInput {
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
  id: StringFilter
  userId: StringFilter
  postId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  post: PostRelationFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input CommentListRelationFilter {
  every: CommentWhereInput
  some: CommentWhereInput
  none: CommentWhereInput
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  id: StringFilter
  text: StringFilter
  postId: StringFilter
  userId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  post: PostRelationFilter
  user: UserRelationFilter
}

input UserOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  username: SortOrder
  userStatus: SortOrder
  password: SortOrder
  role: SortOrder
  posts: PostOrderByRelationAggregateInput
  likes: LikeOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
}

enum SortOrder {
  asc
  desc
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input LikeOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserWhereUniqueInput {
  id: String
  email: String
  username: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userStatus: StringFilter
  password: StringFilter
  role: EnumRoleFilter
  posts: PostListRelationFilter
  likes: LikeListRelationFilter
  comments: CommentListRelationFilter
}

enum UserScalarFieldEnum {
  id
  createdAt
  updatedAt
  email
  username
  userStatus
  password
  role
}

enum RelationLoadStrategy {
  query
  join
}

input UserOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  username: SortOrder
  userStatus: SortOrder
  password: SortOrder
  role: SortOrder
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  username: SortOrder
  userStatus: SortOrder
  password: SortOrder
  role: SortOrder
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  username: SortOrder
  userStatus: SortOrder
  password: SortOrder
  role: SortOrder
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  username: SortOrder
  userStatus: SortOrder
  password: SortOrder
  role: SortOrder
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  username: StringWithAggregatesFilter
  userStatus: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

input StringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input NestedStringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input EnumRoleWithAggregatesFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumRoleFilter
  _max: NestedEnumRoleFilter
}

input NestedEnumRoleWithAggregatesFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumRoleFilter
  _max: NestedEnumRoleFilter
}

input UserCountAggregateInput {
  id: Boolean
  createdAt: Boolean
  updatedAt: Boolean
  email: Boolean
  username: Boolean
  userStatus: Boolean
  password: Boolean
  role: Boolean
  _all: Boolean
}

input UserMinAggregateInput {
  id: Boolean
  createdAt: Boolean
  updatedAt: Boolean
  email: Boolean
  username: Boolean
  userStatus: Boolean
  password: Boolean
  role: Boolean
}

input UserMaxAggregateInput {
  id: Boolean
  createdAt: Boolean
  updatedAt: Boolean
  email: Boolean
  username: Boolean
  userStatus: Boolean
  password: Boolean
  role: Boolean
}

input PostOrderByWithRelationInput {
  id: SortOrder
  url: SortOrderInput
  createdAt: SortOrder
  views: SortOrder
  updatedAt: SortOrder
  published: SortOrder
  title: SortOrder
  content: SortOrder
  authorId: SortOrderInput
  author: UserOrderByWithRelationInput
  categories: CategoriesOnPostsOrderByRelationAggregateInput
  likes: LikeOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
}

input SortOrderInput {
  sort: SortOrder!
  nulls: NullsOrder
}

enum NullsOrder {
  first
  last
}

input CategoriesOnPostsOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostWhereUniqueInput {
  id: String
  url: String
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
  createdAt: DateTimeFilter
  views: IntFilter
  updatedAt: DateTimeFilter
  published: BoolFilter
  title: StringFilter
  content: StringFilter
  authorId: StringNullableFilter
  author: UserNullableRelationFilter
  categories: CategoriesOnPostsListRelationFilter
  likes: LikeListRelationFilter
  comments: CommentListRelationFilter
}

enum PostScalarFieldEnum {
  id
  url
  createdAt
  views
  updatedAt
  published
  title
  content
  authorId
}

input PostOrderByWithAggregationInput {
  id: SortOrder
  url: SortOrderInput
  createdAt: SortOrder
  views: SortOrder
  updatedAt: SortOrder
  published: SortOrder
  title: SortOrder
  content: SortOrder
  authorId: SortOrderInput
  _count: PostCountOrderByAggregateInput
  _avg: PostAvgOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
}

input PostCountOrderByAggregateInput {
  id: SortOrder
  url: SortOrder
  createdAt: SortOrder
  views: SortOrder
  updatedAt: SortOrder
  published: SortOrder
  title: SortOrder
  content: SortOrder
  authorId: SortOrder
}

input PostAvgOrderByAggregateInput {
  views: SortOrder
}

input PostMaxOrderByAggregateInput {
  id: SortOrder
  url: SortOrder
  createdAt: SortOrder
  views: SortOrder
  updatedAt: SortOrder
  published: SortOrder
  title: SortOrder
  content: SortOrder
  authorId: SortOrder
}

input PostMinOrderByAggregateInput {
  id: SortOrder
  url: SortOrder
  createdAt: SortOrder
  views: SortOrder
  updatedAt: SortOrder
  published: SortOrder
  title: SortOrder
  content: SortOrder
  authorId: SortOrder
}

input PostSumOrderByAggregateInput {
  views: SortOrder
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  url: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  views: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  published: BoolWithAggregatesFilter
  title: StringWithAggregatesFilter
  content: StringWithAggregatesFilter
  authorId: StringNullableWithAggregatesFilter
}

input StringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

input NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

input NestedIntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input IntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input BoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

input PostCountAggregateInput {
  id: Boolean
  url: Boolean
  createdAt: Boolean
  views: Boolean
  updatedAt: Boolean
  published: Boolean
  title: Boolean
  content: Boolean
  authorId: Boolean
  _all: Boolean
}

input PostAvgAggregateInput {
  views: Boolean
}

input PostSumAggregateInput {
  views: Boolean
}

input PostMinAggregateInput {
  id: Boolean
  url: Boolean
  createdAt: Boolean
  views: Boolean
  updatedAt: Boolean
  published: Boolean
  title: Boolean
  content: Boolean
  authorId: Boolean
}

input PostMaxAggregateInput {
  id: Boolean
  url: Boolean
  createdAt: Boolean
  views: Boolean
  updatedAt: Boolean
  published: Boolean
  title: Boolean
  content: Boolean
  authorId: Boolean
}

type Mutation {
  addRecipe(newRecipeData: NewRecipeInput!): Recipe!
  removeRecipe(id: String!): Boolean!
  createUser(data: UserCreateInput!, relationLoadStrategy: RelationLoadStrategy): User
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRows
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRows
  deleteUser(where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  deleteManyUser(where: UserWhereInput): AffectedRows
  registerUser(userCreateInput: UserCreateInput!): User!
  createPost(postCreateInput: PostCreateInput!): Post
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRows
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRows
  deletePost(where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  deleteManyPost(where: PostWhereInput): AffectedRows
}

input NewRecipeInput {
  title: String!
  description: String
  ingredients: [String!]!
}

input UserCreateInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String!
  username: String!
  userStatus: String
  password: String!
  role: Role
  posts: PostCreateNestedManyWithoutAuthorInput
  likes: LikeCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
}

input PostCreateNestedManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  connect: [PostWhereUniqueInput!]
}

input PostCreateWithoutAuthorInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
  categories: CategoriesOnPostsCreateNestedManyWithoutPostInput
  likes: LikeCreateNestedManyWithoutPostInput
  comments: CommentCreateNestedManyWithoutPostInput
}

input CategoriesOnPostsCreateNestedManyWithoutPostInput {
  create: [CategoriesOnPostsCreateWithoutPostInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutPostInput!]
  createMany: CategoriesOnPostsCreateManyPostInputEnvelope
  connect: [CategoriesOnPostsWhereUniqueInput!]
}

input CategoriesOnPostsCreateWithoutPostInput {
  assignedAt: DateTime
  assignedBy: String!
  category: CategoryCreateNestedOneWithoutPostsInput!
}

input CategoryCreateNestedOneWithoutPostsInput {
  create: CategoryCreateWithoutPostsInput
  connectOrCreate: CategoryCreateOrConnectWithoutPostsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutPostsInput {
  id: String
  name: String!
  description: String
}

input CategoryCreateOrConnectWithoutPostsInput {
  where: CategoryWhereUniqueInput!
  create: CategoryCreateWithoutPostsInput!
}

input CategoryWhereUniqueInput {
  id: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  name: StringFilter
  description: StringNullableFilter
  posts: CategoriesOnPostsListRelationFilter
}

input CategoriesOnPostsCreateOrConnectWithoutPostInput {
  where: CategoriesOnPostsWhereUniqueInput!
  create: CategoriesOnPostsCreateWithoutPostInput!
}

input CategoriesOnPostsWhereUniqueInput {
  postId_categoryId: CategoriesOnPostsPostIdCategoryIdCompoundUniqueInput
  AND: [CategoriesOnPostsWhereInput!]
  OR: [CategoriesOnPostsWhereInput!]
  NOT: [CategoriesOnPostsWhereInput!]
  postId: StringFilter
  categoryId: StringFilter
  assignedAt: DateTimeFilter
  assignedBy: StringFilter
  post: PostRelationFilter
  category: CategoryRelationFilter
}

input CategoriesOnPostsPostIdCategoryIdCompoundUniqueInput {
  postId: String!
  categoryId: String!
}

input CategoriesOnPostsCreateManyPostInputEnvelope {
  data: [CategoriesOnPostsCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input CategoriesOnPostsCreateManyPostInput {
  categoryId: String!
  assignedAt: DateTime
  assignedBy: String!
}

input LikeCreateNestedManyWithoutPostInput {
  create: [LikeCreateWithoutPostInput!]
  connectOrCreate: [LikeCreateOrConnectWithoutPostInput!]
  createMany: LikeCreateManyPostInputEnvelope
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutPostInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutLikesInput!
}

input UserCreateNestedOneWithoutLikesInput {
  create: UserCreateWithoutLikesInput
  connectOrCreate: UserCreateOrConnectWithoutLikesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLikesInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String!
  username: String!
  userStatus: String
  password: String!
  role: Role
  posts: PostCreateNestedManyWithoutAuthorInput
  comments: CommentCreateNestedManyWithoutUserInput
}

input CommentCreateNestedManyWithoutUserInput {
  create: [CommentCreateWithoutUserInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutUserInput {
  id: String
  text: String!
  createdAt: DateTime
  updatedAt: DateTime
  post: PostCreateNestedOneWithoutCommentsInput!
}

input PostCreateNestedOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutCommentsInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
  author: UserCreateNestedOneWithoutPostsInput
  categories: CategoriesOnPostsCreateNestedManyWithoutPostInput
  likes: LikeCreateNestedManyWithoutPostInput
}

input UserCreateNestedOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPostsInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String!
  username: String!
  userStatus: String
  password: String!
  role: Role
  likes: LikeCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
}

input LikeCreateNestedManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  connectOrCreate: [LikeCreateOrConnectWithoutUserInput!]
  createMany: LikeCreateManyUserInputEnvelope
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutUserInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  post: PostCreateNestedOneWithoutLikesInput!
}

input PostCreateNestedOneWithoutLikesInput {
  create: PostCreateWithoutLikesInput
  connectOrCreate: PostCreateOrConnectWithoutLikesInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutLikesInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
  author: UserCreateNestedOneWithoutPostsInput
  categories: CategoriesOnPostsCreateNestedManyWithoutPostInput
  comments: CommentCreateNestedManyWithoutPostInput
}

input CommentCreateNestedManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutPostInput {
  id: String
  text: String!
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput!
}

input UserCreateNestedOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String!
  username: String!
  userStatus: String
  password: String!
  role: Role
  posts: PostCreateNestedManyWithoutAuthorInput
  likes: LikeCreateNestedManyWithoutUserInput
}

input UserCreateOrConnectWithoutCommentsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutPostInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereUniqueInput {
  id: String
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  text: StringFilter
  postId: StringFilter
  userId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  post: PostRelationFilter
  user: UserRelationFilter
}

input CommentCreateManyPostInputEnvelope {
  data: [CommentCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyPostInput {
  id: String
  text: String!
  userId: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input PostCreateOrConnectWithoutLikesInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutLikesInput!
}

input LikeCreateOrConnectWithoutUserInput {
  where: LikeWhereUniqueInput!
  create: LikeCreateWithoutUserInput!
}

input LikeWhereUniqueInput {
  id: String
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
  userId: StringFilter
  postId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  post: PostRelationFilter
}

input LikeCreateManyUserInputEnvelope {
  data: [LikeCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input LikeCreateManyUserInput {
  id: String
  postId: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input UserCreateOrConnectWithoutPostsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutPostsInput!
}

input PostCreateOrConnectWithoutCommentsInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutUserInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutUserInput!
}

input CommentCreateManyUserInputEnvelope {
  data: [CommentCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  id: String
  text: String!
  postId: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input UserCreateOrConnectWithoutLikesInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutLikesInput!
}

input LikeCreateOrConnectWithoutPostInput {
  where: LikeWhereUniqueInput!
  create: LikeCreateWithoutPostInput!
}

input LikeCreateManyPostInputEnvelope {
  data: [LikeCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input LikeCreateManyPostInput {
  id: String
  userId: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input PostCreateOrConnectWithoutAuthorInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutAuthorInput!
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyAuthorInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
}

input UserCreateManyInput {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  email: String!
  username: String!
  userStatus: String
  password: String!
  role: Role
}

input UserUpdateInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  userStatus: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  likes: LikeUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
}

input StringFieldUpdateOperationsInput {
  set: String
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input PostUpdateManyWithoutAuthorNestedInput {
  create: [PostCreateWithoutAuthorInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorInput!
  create: PostCreateWithoutAuthorInput!
}

input PostUpdateWithoutAuthorInput {
  id: StringFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  views: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  categories: CategoriesOnPostsUpdateManyWithoutPostNestedInput
  likes: LikeUpdateManyWithoutPostNestedInput
  comments: CommentUpdateManyWithoutPostNestedInput
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input CategoriesOnPostsUpdateManyWithoutPostNestedInput {
  create: [CategoriesOnPostsCreateWithoutPostInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutPostInput!]
  upsert: [CategoriesOnPostsUpsertWithWhereUniqueWithoutPostInput!]
  createMany: CategoriesOnPostsCreateManyPostInputEnvelope
  set: [CategoriesOnPostsWhereUniqueInput!]
  disconnect: [CategoriesOnPostsWhereUniqueInput!]
  delete: [CategoriesOnPostsWhereUniqueInput!]
  connect: [CategoriesOnPostsWhereUniqueInput!]
  update: [CategoriesOnPostsUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CategoriesOnPostsUpdateManyWithWhereWithoutPostInput!]
  deleteMany: [CategoriesOnPostsScalarWhereInput!]
}

input CategoriesOnPostsUpsertWithWhereUniqueWithoutPostInput {
  where: CategoriesOnPostsWhereUniqueInput!
  update: CategoriesOnPostsUpdateWithoutPostInput!
  create: CategoriesOnPostsCreateWithoutPostInput!
}

input CategoriesOnPostsUpdateWithoutPostInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  assignedBy: StringFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutPostsNestedInput
}

input CategoryUpdateOneRequiredWithoutPostsNestedInput {
  create: CategoryCreateWithoutPostsInput
  connectOrCreate: CategoryCreateOrConnectWithoutPostsInput
  upsert: CategoryUpsertWithoutPostsInput
  connect: CategoryWhereUniqueInput
  update: CategoryUpdateToOneWithWhereWithoutPostsInput
}

input CategoryUpsertWithoutPostsInput {
  update: CategoryUpdateWithoutPostsInput!
  create: CategoryCreateWithoutPostsInput!
  where: CategoryWhereInput
}

input CategoryUpdateWithoutPostsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
}

input CategoryUpdateToOneWithWhereWithoutPostsInput {
  where: CategoryWhereInput
  data: CategoryUpdateWithoutPostsInput!
}

input CategoriesOnPostsUpdateWithWhereUniqueWithoutPostInput {
  where: CategoriesOnPostsWhereUniqueInput!
  data: CategoriesOnPostsUpdateWithoutPostInput!
}

input CategoriesOnPostsUpdateManyWithWhereWithoutPostInput {
  where: CategoriesOnPostsScalarWhereInput!
  data: CategoriesOnPostsUpdateManyMutationInput!
}

input CategoriesOnPostsScalarWhereInput {
  AND: [CategoriesOnPostsScalarWhereInput!]
  OR: [CategoriesOnPostsScalarWhereInput!]
  NOT: [CategoriesOnPostsScalarWhereInput!]
  postId: StringFilter
  categoryId: StringFilter
  assignedAt: DateTimeFilter
  assignedBy: StringFilter
}

input CategoriesOnPostsUpdateManyMutationInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  assignedBy: StringFieldUpdateOperationsInput
}

input LikeUpdateManyWithoutPostNestedInput {
  create: [LikeCreateWithoutPostInput!]
  connectOrCreate: [LikeCreateOrConnectWithoutPostInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutPostInput!]
  createMany: LikeCreateManyPostInputEnvelope
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [LikeUpdateManyWithWhereWithoutPostInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpsertWithWhereUniqueWithoutPostInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutPostInput!
  create: LikeCreateWithoutPostInput!
}

input LikeUpdateWithoutPostInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutLikesNestedInput
}

input UserUpdateOneRequiredWithoutLikesNestedInput {
  create: UserCreateWithoutLikesInput
  connectOrCreate: UserCreateOrConnectWithoutLikesInput
  upsert: UserUpsertWithoutLikesInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutLikesInput
}

input UserUpsertWithoutLikesInput {
  update: UserUpdateWithoutLikesInput!
  create: UserCreateWithoutLikesInput!
  where: UserWhereInput
}

input UserUpdateWithoutLikesInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  userStatus: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
}

input CommentUpdateManyWithoutUserNestedInput {
  create: [CommentCreateWithoutUserInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutUserInput!
  create: CommentCreateWithoutUserInput!
}

input CommentUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsNestedInput
}

input PostUpdateOneRequiredWithoutCommentsNestedInput {
  create: PostCreateWithoutCommentsInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
  update: PostUpdateToOneWithWhereWithoutCommentsInput
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsInput!
  create: PostCreateWithoutCommentsInput!
  where: PostWhereInput
}

input PostUpdateWithoutCommentsInput {
  id: StringFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  views: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  author: UserUpdateOneWithoutPostsNestedInput
  categories: CategoriesOnPostsUpdateManyWithoutPostNestedInput
  likes: LikeUpdateManyWithoutPostNestedInput
}

input UserUpdateOneWithoutPostsNestedInput {
  create: UserCreateWithoutPostsInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
  disconnect: UserWhereInput
  delete: UserWhereInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutPostsInput
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsInput!
  create: UserCreateWithoutPostsInput!
  where: UserWhereInput
}

input UserUpdateWithoutPostsInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  userStatus: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  likes: LikeUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
}

input LikeUpdateManyWithoutUserNestedInput {
  create: [LikeCreateWithoutUserInput!]
  connectOrCreate: [LikeCreateOrConnectWithoutUserInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutUserInput!]
  createMany: LikeCreateManyUserInputEnvelope
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LikeUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutUserInput!
  create: LikeCreateWithoutUserInput!
}

input LikeUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutLikesNestedInput
}

input PostUpdateOneRequiredWithoutLikesNestedInput {
  create: PostCreateWithoutLikesInput
  connectOrCreate: PostCreateOrConnectWithoutLikesInput
  upsert: PostUpsertWithoutLikesInput
  connect: PostWhereUniqueInput
  update: PostUpdateToOneWithWhereWithoutLikesInput
}

input PostUpsertWithoutLikesInput {
  update: PostUpdateWithoutLikesInput!
  create: PostCreateWithoutLikesInput!
  where: PostWhereInput
}

input PostUpdateWithoutLikesInput {
  id: StringFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  views: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  author: UserUpdateOneWithoutPostsNestedInput
  categories: CategoriesOnPostsUpdateManyWithoutPostNestedInput
  comments: CommentUpdateManyWithoutPostNestedInput
}

input CommentUpdateManyWithoutPostNestedInput {
  create: [CommentCreateWithoutPostInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostInput!
  create: CommentCreateWithoutPostInput!
}

input CommentUpdateWithoutPostInput {
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCommentsNestedInput
}

input UserUpdateOneRequiredWithoutCommentsNestedInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutCommentsInput
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsInput!
  create: UserCreateWithoutCommentsInput!
  where: UserWhereInput
}

input UserUpdateWithoutCommentsInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  userStatus: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  likes: LikeUpdateManyWithoutUserNestedInput
}

input UserUpdateToOneWithWhereWithoutCommentsInput {
  where: UserWhereInput
  data: UserUpdateWithoutCommentsInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostInput!
}

input CommentUpdateManyWithWhereWithoutPostInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  id: StringFilter
  text: StringFilter
  postId: StringFilter
  userId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input CommentUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateToOneWithWhereWithoutLikesInput {
  where: PostWhereInput
  data: PostUpdateWithoutLikesInput!
}

input LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutUserInput!
}

input LikeUpdateManyWithWhereWithoutUserInput {
  where: LikeScalarWhereInput!
  data: LikeUpdateManyMutationInput!
}

input LikeScalarWhereInput {
  AND: [LikeScalarWhereInput!]
  OR: [LikeScalarWhereInput!]
  NOT: [LikeScalarWhereInput!]
  id: StringFilter
  userId: StringFilter
  postId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input LikeUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateToOneWithWhereWithoutPostsInput {
  where: UserWhereInput
  data: UserUpdateWithoutPostsInput!
}

input PostUpdateToOneWithWhereWithoutCommentsInput {
  where: PostWhereInput
  data: PostUpdateWithoutCommentsInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutUserInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input UserUpdateToOneWithWhereWithoutLikesInput {
  where: UserWhereInput
  data: UserUpdateWithoutLikesInput!
}

input LikeUpdateWithWhereUniqueWithoutPostInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutPostInput!
}

input LikeUpdateManyWithWhereWithoutPostInput {
  where: LikeScalarWhereInput!
  data: LikeUpdateManyMutationInput!
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorInput!
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyMutationInput!
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  id: StringFilter
  url: StringNullableFilter
  createdAt: DateTimeFilter
  views: IntFilter
  updatedAt: DateTimeFilter
  published: BoolFilter
  title: StringFilter
  content: StringFilter
  authorId: StringNullableFilter
}

input PostUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  views: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  userStatus: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input PostCreateInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
  author: UserCreateNestedOneWithoutPostsInput
  categories: CategoriesOnPostsCreateNestedManyWithoutPostInput
  likes: LikeCreateNestedManyWithoutPostInput
  comments: CommentCreateNestedManyWithoutPostInput
}

input PostCreateManyInput {
  id: String
  url: String
  createdAt: DateTime
  views: Int
  updatedAt: DateTime
  published: Boolean!
  title: String!
  content: String!
  authorId: String
}

input PostUpdateInput {
  id: StringFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  views: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  author: UserUpdateOneWithoutPostsNestedInput
  categories: CategoriesOnPostsUpdateManyWithoutPostNestedInput
  likes: LikeUpdateManyWithoutPostNestedInput
  comments: CommentUpdateManyWithoutPostNestedInput
}

type Subscription {
  recipeAdded: Recipe!
}